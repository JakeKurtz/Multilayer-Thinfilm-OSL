/* ------------------------------------------------------------------------- *
*
*    Copyright (C) 2023 Jake Kurtz
*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program. If not, see <https://www.gnu.org/licenses/>.
*
* ------------------------------------------------------------------------- */

#include "spectral.h"
#include "thinfilm.h"
#include "complex.h"
#include "ior.h"

#define LAYERS 3
#define SPECTRAL

void thin_film(float lambda, complex n[LAYERS], float d[LAYERS], complex cos_theta[LAYERS], output float R, output float T)
{
    cmatrix22 Ts = identity();
    cmatrix22 Tp = identity();

    complex n_i; complex ct_i;
    complex n_j; complex ct_j;

    complex rs_ij; complex ts_ij;
    complex rs_ji; complex ts_ji;
    complex rp_ij; complex tp_ij;
    complex rp_ji; complex tp_ji;

    for (int i = 0; i < LAYERS-1; i++) 
    {
        n_i = n[i];   ct_i = cos_theta[i];
        n_j = n[i+1]; ct_j = cos_theta[i+1];

        compute_polarization(
            n_i,   n_j,   ct_i,  ct_j,
            rp_ij, rs_ij, ts_ij, tp_ij
        );
        compute_polarization(
            n_j,   n_i,   ct_j,  ct_i,
            rp_ji, rs_ji, ts_ji, tp_ji
        );

        cmatrix22 Ds_i = D_mat(rs_ij, rs_ji, ts_ij, ts_ji);
        cmatrix22 Dp_i = D_mat(rp_ij, rp_ji, tp_ij, tp_ji);
        cmatrix22 P_i = P_mat(lambda, n_i, d[i], ct_i);

        Ts = Ts*P_i*Ds_i;
        Tp = Tp*P_i*Dp_i;
    }
    
    complex r_s = Ts.t10 / Ts.t00;
    complex r_p = Tp.t10 / Tp.t00;

    complex t_s = 1.0 / Ts.t00;
    complex t_p = 1.0 / Tp.t00;

    float R_s = modulus_sqrd(r_s);
    float R_p = modulus_sqrd(r_p);

    complex x = n[LAYERS-1] * cos_theta[LAYERS-1];
    complex y = conjugate(n[LAYERS-1]) * cos_theta[LAYERS-1];
    float z = n[0].r * cos_theta[0].r;

    float T_s = (modulus_sqrd(t_s) * x.r) / z;
    float T_p = (modulus_sqrd(t_p) * y.r) / z;

    R = (R_s + R_p) * 0.5;
    T = (T_s + T_p) * 0.5;
}

void sample_interfaces(float lambda, float sin_theta_0, IOR n_ior[LAYERS], output complex n[LAYERS], output complex cos_theta[LAYERS])
{
    n[0] = sample_IOR(lambda, n_ior[0]);
    n[1] = sample_IOR(lambda, n_ior[1]);
    n[2] = sample_IOR(lambda, n_ior[2]);

    cos_theta[1] = cos_theta_i(n[1], n[0], sin_theta_0);
    cos_theta[2] = cos_theta_i(n[2], n[0], sin_theta_0);
}

shader ThinFilm
(
color film_0_IOR = 1.475
[[ string label = "Film IOR"]],
color absorption_0 = 0.0
[[ string label = "Film Absorption"]],
float film_0_thickness = 500.0
[[ string label = "Film Thickness"]],
color base_IOR = 1.5
[[ string label = "Base IOR"]],
color base_absorption = 0.0
[[ string label = "Base Absorption"]],
normal Normal = N,
vector Incident = I,
output color R = color(1.0),
output color T = color(0.0)
)
{
    float d[LAYERS];

    d[0] = INFINITE;
    d[1] = film_0_thickness;
    d[2] = INFINITE;

    complex n[LAYERS]; IOR n_ior[LAYERS];
    complex cos_theta[LAYERS];

    color eta_0 = backfacing() ? 1.0/film_0_IOR : film_0_IOR;
    color eta_1 = backfacing() ? 1.0/base_IOR : base_IOR;

    n_ior[0] = IOR(color(1.0), color(0.0));
    n_ior[1] = IOR(eta_0,      absorption_0);
    n_ior[2] = IOR(eta_1,      base_absorption);

    cos_theta[0] = complex(max(dot(Normal, Incident), 1e-6), 0.0);
    float sin_theta_0 = sqrt(1.0 - pow(cos_theta[0].r, 2.0));

#ifdef SPECTRAL
    float lambda_samples[LAMBDA_SAMPLES];
    gen_lambda_samples(P, lambda_samples);

    float spec_R[LAMBDA_SAMPLES];
    float spec_T[LAMBDA_SAMPLES];

    for (int i = 0; i < LAMBDA_SAMPLES; i++) {
        sample_interfaces(lambda_samples[i], sin_theta_0, n_ior, n, cos_theta);
        thin_film(lambda_samples[i], n, d, cos_theta, spec_R[i], spec_T[i]);
    }

    color rgb_R = SPEC_to_RGB(spec_R, lambda_samples);
    color rgb_T = SPEC_to_RGB(spec_T, lambda_samples);

    R = rgb_R;
    T = rgb_T;
#else
    sample_interfaces(650.0, sin_theta_0, n_ior, n, cos_theta);
    thin_film(650.0, n, d, cos_theta, R.r, T.r);

    sample_interfaces(532.0, sin_theta_0, n_ior, n, cos_theta);
    thin_film(532.0, n, d, cos_theta, R.g, T.g);

    sample_interfaces(450.0, sin_theta_0, n_ior, n, cos_theta);
    thin_film(450.0, n, d, cos_theta, R.b, T.b);
#endif
}